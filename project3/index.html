<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algo | Data Lab</title>
    <link rel="stylesheet" href="../assets/site.css">
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.469.0/dist/umd/lucide.min.js"></script>
    <style>
        .canvas-container {
            position: relative;
            width: 100%;
            height: 480px;
            /* Background will be managed by JS/CSS variables */
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .stats-panel span {
            color: var(--primary);
            font-weight: 600;
        }

        .card-no-padding {
            padding: 8px !important;
        }
    </style>
</head>

<body data-lab-name="Data Lab" data-page-name="Genetic Algorithms & Evolution" data-home="../index.html">
    <div class="container">
        <header>
            <div class="header-content">
                <a href="../index.html" class="back-link">
                    <i data-lucide="arrow-left"></i> Back to Hub
                </a>
                <h1 data-i18n="title">Genetic Algorithms & Evolution</h1>
                <p class="subtitle" data-i18n="subtitle">Evolving autonomous agents to find a target. 'Smart Rockets'.
                </p>
            </div>
        </header>

        <div class="grid">
            <div class="card">
                <div class="card-header"><i data-lucide="settings"></i> <span data-i18n="config">Configuration</span>
                </div>

                <div class="form-group">
                    <label><span data-i18n="popSize">Population Size</span>: <span id="popVal">50</span></label>
                    <input type="range" id="popSize" min="10" max="200" step="10" value="50">
                </div>

                <div class="form-group">
                    <label><span data-i18n="mutation">Mutation Rate</span>: <span id="mutVal">0.01</span></label>
                    <input type="range" id="mutRate" min="0" max="0.1" step="0.005" value="0.01">
                </div>

                <div class="action-row">
                    <button id="btnRun" class="btn primary">Start/Pause</button>
                    <button id="btnReset" class="btn btn-secondary">Reset</button>
                </div>

                <div class="stats-panel" style="margin-top:20px; font-family:monospace; color:var(--text-light);">
                    <div>Generation: <span id="gen">1</span></div>
                    <div>Max Fitness: <span id="maxFit">0.0000</span></div>
                </div>
            </div>

            <div class="card card-no-padding">
                <div class="canvas-container">
                    <canvas id="simCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const translations = {
            en: {
                title: 'Genetic Algorithms & Evolution',
                subtitle: 'Evolving autonomous agents to find a target. "Smart Rockets".',
                config: 'Configuration',
                popSize: 'Population Size',
                mutation: 'Mutation Rate',
                viz: 'Simulation'
            },
            pl: {
                title: 'Algorytmy Genetyczne',
                subtitle: 'Ewolucja agentów szukających celu. "Mądre Rakiety".',
                config: 'Konfiguracja',
                popSize: 'Rozmiar Populacji',
                mutation: 'Wskaźnik Mutacji',
                viz: 'Symulacja'
            }
        };

        class Vec {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; }
            mult(n) { this.x *= n; this.y *= n; }
            limit(max) {
                const mSq = this.x * this.x + this.y * this.y;
                if (mSq > max * max) {
                    const m = Math.sqrt(mSq);
                    this.mult(max / m);
                }
            }
            static random() {
                const angle = Math.random() * Math.PI * 2;
                return new Vec(Math.cos(angle), Math.sin(angle));
            }
        }

        class DNA {
            constructor(genes, lifespan) {
                if (genes) {
                    this.genes = genes;
                } else {
                    this.genes = [];
                    for (let i = 0; i < lifespan; i++) {
                        const v = Vec.random();
                        v.mult(0.2);
                        this.genes.push(v);
                    }
                }
            }
            crossover(partner, midpoint) {
                const newGenes = [];
                for (let i = 0; i < this.genes.length; i++) {
                    newGenes[i] = (i < midpoint) ? this.genes[i] : partner.genes[i];
                }
                return new DNA(newGenes);
            }
            mutation(rate) {
                for (let i = 0; i < this.genes.length; i++) {
                    if (Math.random() < rate) {
                        const v = Vec.random();
                        v.mult(0.2);
                        this.genes[i] = v;
                    }
                }
            }
        }

        class Rocket {
            constructor(dna, x, y, lifespan) {
                this.pos = new Vec(x, y);
                this.vel = new Vec(0, 0);
                this.acc = new Vec(0, 0);
                this.dna = dna || new DNA(null, lifespan);
                this.fitness = 0;
                this.completed = false;
                this.crashed = false;
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update(count, target, obst, w, h) {
                const d = Math.sqrt((this.pos.x - target.x) ** 2 + (this.pos.y - target.y) ** 2);
                if (d < 16) {
                    this.completed = true;
                    this.pos = new Vec(target.x, target.y);
                }

                // Obstacle Hit
                if (this.pos.x > obst.x && this.pos.x < obst.x + obst.w && this.pos.y > obst.y && this.pos.y < obst.y + obst.h) {
                    this.crashed = true;
                }
                // Bounds Hit
                if (this.pos.x < 0 || this.pos.x > w || this.pos.y < 0 || this.pos.y > h) {
                    this.crashed = true;
                }

                if (!this.completed && !this.crashed) {
                    this.applyForce(this.dna.genes[count]);
                    this.vel.add(this.acc);
                    this.pos.add(this.vel);
                    this.acc.mult(0);
                }
            }

            calcFitness(target) {
                const d = Math.sqrt((this.pos.x - target.x) ** 2 + (this.pos.y - target.y) ** 2);
                this.fitness = 1 / (d + 1);
                if (this.completed) this.fitness *= 10;
                if (this.crashed) this.fitness /= 20;
            }
        }

        class Population {
            constructor(size, lifecycle, startX, startY) {
                this.rockets = [];
                this.size = size;
                this.lifecycle = lifecycle;
                this.startX = startX;
                this.startY = startY;
                this.matingPool = [];

                for (let i = 0; i < size; i++) {
                    this.rockets[i] = new Rocket(null, startX, startY, lifecycle);
                }
            }

            evaluate(target) {
                let maxFit = 0;
                this.rockets.forEach(r => {
                    r.calcFitness(target);
                    if (r.fitness > maxFit) maxFit = r.fitness;
                });

                this.matingPool = [];
                this.rockets.forEach(r => {
                    const n = Math.floor((r.fitness / maxFit) * 100);
                    for (let j = 0; j < n; j++) {
                        this.matingPool.push(r);
                    }
                });
                return maxFit;
            }

            selection(mutationRate) {
                const newRockets = [];
                for (let i = 0; i < this.rockets.length; i++) {
                    const parentA = this.matingPool[Math.floor(Math.random() * this.matingPool.length)].dna;
                    const parentB = this.matingPool[Math.floor(Math.random() * this.matingPool.length)].dna;
                    const mid = Math.floor(Math.random() * this.lifecycle);
                    const childDNA = parentA.crossover(parentB, mid);
                    childDNA.mutation(mutationRate);
                    newRockets[i] = new Rocket(childDNA, this.startX, this.startY, this.lifecycle);
                }
                this.rockets = newRockets;
            }

            run(count, target, obstacle, w, h) {
                this.rockets.forEach(r => r.update(count, target, obstacle, w, h));
            }
        }

        const app = {
            lang: 'en',
            pop: null,
            target: { x: 0, y: 0 },
            obstacle: { x: 0, y: 0, w: 0, h: 0 },
            lifespan: 250,
            count: 0,
            gen: 1,
            isRunning: false,

            init: () => {
                app.canvas = document.getElementById('simCanvas');
                app.ctx = app.canvas.getContext('2d');

                window.addEventListener('resize', app.resize);
                app.resize();

                app.lang = document.documentElement.getAttribute('lang') || 'en';
                app.updateTranslations();

                window.addEventListener('themechange', () => {
                    app.draw();
                });

                document.getElementById('btnRun').addEventListener('click', () => {
                    app.isRunning = !app.isRunning;
                    if (app.isRunning) app.loop();
                });
                document.getElementById('btnReset').addEventListener('click', app.reset);

                app.reset();
            },

            resize: () => {
                const container = app.canvas.parentElement;
                app.canvas.width = container.clientWidth;
                app.canvas.height = container.clientHeight;

                app.target = { x: app.canvas.width / 2, y: 50 };
                app.obstacle = {
                    x: app.canvas.width * 0.2,
                    y: app.canvas.height * 0.5,
                    w: app.canvas.width * 0.6,
                    h: 12
                };
                app.draw();
            },

            updateTranslations: () => {
                const t = translations[app.lang] || translations.en;
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key]) el.textContent = t[key];
                });
            },

            reset: () => {
                const size = parseInt(document.getElementById('popSize').value);
                app.pop = new Population(size, app.lifespan, app.canvas.width / 2, app.canvas.height - 30);
                app.count = 0;
                app.gen = 1;
                app.isRunning = false;
                app.draw();
                document.getElementById('gen').textContent = 1;
                document.getElementById('maxFit').textContent = '0.0000'
            },

            loop: () => {
                if (!app.isRunning) return;

                app.pop.run(app.count, app.target, app.obstacle, app.canvas.width, app.canvas.height);
                app.count++;

                if (app.count >= app.lifespan) {
                    const mut = parseFloat(document.getElementById('mutRate').value);
                    const maxFit = app.pop.evaluate(app.target);
                    app.pop.selection(mut);
                    app.count = 0;
                    app.gen++;
                    document.getElementById('gen').textContent = app.gen;
                    document.getElementById('maxFit').textContent = maxFit.toFixed(5);
                }

                app.draw();
                requestAnimationFrame(app.loop);
            },

            draw: () => {
                const ctx = app.ctx;
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const theme = document.documentElement.getAttribute('data-theme') || 'dark';

                ctx.clearRect(0, 0, w, h);

                // Background fill for light mode visibility
                ctx.fillStyle = theme === 'dark' ? '#020617' : '#f8fafc';
                ctx.fillRect(0, 0, w, h);

                // Grid
                ctx.strokeStyle = theme === 'dark' ? 'rgba(255, 255, 255, 0.03)' : 'rgba(0, 0, 0, 0.04)';
                ctx.lineWidth = 1;
                for (let x = 0; x < w; x += 40) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
                }
                for (let y = 0; y < h; y += 40) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                }

                // Target
                const pulse = Math.sin(Date.now() / 200) * 4;
                ctx.fillStyle = '#10b981'; // Emerald
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#10b981';
                ctx.beginPath();
                ctx.arc(app.target.x, app.target.y, 14 + pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Obstacle
                ctx.fillStyle = '#f43f5e'; // Rose
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(244, 63, 94, 0.3)';
                ctx.fillRect(app.obstacle.x, app.obstacle.y, app.obstacle.w, app.obstacle.h);
                ctx.shadowBlur = 0;

                // Rockets
                app.pop.rockets.forEach(r => {
                    ctx.save();
                    ctx.translate(r.pos.x, r.pos.y);
                    const theta = Math.atan2(r.vel.y, r.vel.x);
                    ctx.rotate(theta);

                    if (r.completed) {
                        ctx.fillStyle = '#10b981';
                        ctx.globalAlpha = 0.8;
                    } else if (r.crashed) {
                        ctx.fillStyle = '#f43f5e';
                        ctx.globalAlpha = 0.2;
                    } else {
                        // Theme-aware rocket color
                        ctx.fillStyle = theme === 'dark' ? '#a78bfa' : '#8b5cf6'; // Violet
                        ctx.globalAlpha = 0.9;
                    }

                    ctx.beginPath();
                    ctx.moveTo(12, 0);
                    ctx.lineTo(-8, -5);
                    ctx.lineTo(-8, 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                });
                ctx.globalAlpha = 1.0;
            }
        };

        window.onload = app.init;
    </script>
    <script src="../assets/site.js"></script>
</body>

</html>